type WatchlistCanister = 
 service {
   /// * Adds a token canister ID to the caller's watchlist.
   ///    * Idempotent: adding a token that already exists will not create duplicates.
   add_to_watchlist: (token_canister_id: text) -> (Result_2);
   /// * Creates a new API key. This API key is linked to the caller's principal.
   ///    * @param name A human-readable name for the key.
   ///    * @returns The raw, unhashed API key. THIS IS THE ONLY TIME IT WILL BE VISIBLE.
   create_my_api_key: (name: text, scopes: vec text) -> (text);
   /// * Retrieves the watchlist for the calling user.
   ///    * Returns an empty array if the user has no watchlist yet.
   get_my_watchlist: () -> (vec text) query;
   get_owner: () -> (principal) query;
   get_treasury_balance: (ledger_id: principal) -> (nat);
   http_request: (req: HttpRequest) -> (HttpResponse) query;
   http_request_streaming_callback: (token: StreamingToken) ->
    (opt StreamingCallbackResponse) query;
   http_request_update: (req: HttpRequest) -> (HttpResponse);
   icrc120_upgrade_finished: () -> (UpgradeFinishedResult);
   /// List all API keys owned by the caller.
   ///    * @returns A list of API key metadata (but not the raw keys).
   list_my_api_keys: () -> (vec ApiKeyMetadata) query;
   /// * Removes a token canister ID from the caller's watchlist.
   ///    * Succeeds even if the token is not in the list.
   remove_from_watchlist: (token_canister_id: text) -> (Result_2);
   /// Revoke (delete) an API key owned by the caller.
   ///    * @param key_id The ID of the key to revoke.
   ///    * @returns True if the key was found and revoked, false otherwise.
   revoke_my_api_key: (key_id: text) -> ();
   set_owner: (new_owner: principal) -> (Result_1);
   transformJwksResponse:
    (record {
       context: blob;
       response: HttpRequestResult;
     }) -> (HttpRequestResult) query;
   withdraw: (ledger_id: principal, amount: nat, destination: Destination) ->
    (Result);
 };
type UpgradeFinishedResult = 
 variant {
   Failed: record {
             nat;
             text;
           };
   InProgress: nat;
   Success: nat;
 };
type TreasuryError = 
 variant {
   LedgerTrap: text;
   NotOwner;
   TransferFailed: TransferError;
 };
type TransferError = 
 variant {
   BadBurn: record {min_burn_amount: nat;};
   BadFee: record {expected_fee: nat;};
   CreatedInFuture: record {ledger_time: Timestamp;};
   Duplicate: record {duplicate_of: nat;};
   GenericError: record {
                   error_code: nat;
                   message: text;
                 };
   InsufficientFunds: record {balance: nat;};
   TemporarilyUnavailable;
   TooOld;
 };
type Timestamp = nat64;
type Time = int;
type Subaccount = blob;
type StreamingToken = blob;
type StreamingStrategy = variant {
                           Callback:
                            record {
                              callback: StreamingCallback;
                              token: StreamingToken;
                            };};
type StreamingCallbackResponse = 
 record {
   body: blob;
   token: opt StreamingToken;
 };
type StreamingCallback = func (StreamingToken) ->
                          (opt StreamingCallbackResponse) query;
type Result_2 = 
 variant {
   err: text;
   ok;
 };
type Result_1 = 
 variant {
   err: TreasuryError;
   ok;
 };
type Result = 
 variant {
   err: TreasuryError;
   ok: nat;
 };
type HttpResponse = 
 record {
   body: blob;
   headers: vec Header;
   status_code: nat16;
   streaming_strategy: opt StreamingStrategy;
   upgrade: opt bool;
 };
type HttpRequestResult = 
 record {
   body: blob;
   headers: vec HttpHeader;
   status: nat;
 };
type HttpRequest = 
 record {
   body: blob;
   certificate_version: opt nat16;
   headers: vec Header;
   method: text;
   url: text;
 };
type HttpHeader = 
 record {
   name: text;
   value: text;
 };
type Header = 
 record {
   text;
   text;
 };
type HashedApiKey = text;
type Destination = 
 record {
   owner: principal;
   subaccount: opt Subaccount;
 };
type ApiKeyMetadata = 
 record {
   hashed_key: HashedApiKey;
   info: ApiKeyInfo;
 };
type ApiKeyInfo = 
 record {
   created: Time;
   name: text;
   "principal": principal;
   scopes: vec text;
 };
service : (args: opt record {owner: opt principal;}) -> WatchlistCanister
