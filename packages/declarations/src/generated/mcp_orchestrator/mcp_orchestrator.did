type canister_install_mode = 
 variant {
   install;
   reinstall;
   upgrade:
    opt
     record {
       skip_pre_upgrade: opt bool;
       wasm_memory_persistence: opt variant {
                                      keep;
                                      replace;
                                    };
     };
 };
type Value = 
 variant {
   Array: vec Value;
   Blob: blob;
   Int: int;
   Map: vec record {
              text;
              Value;
            };
   Nat: nat;
   Text: text;
 };
type UpgradeToResult = 
 variant {
   Err: UpgradeToError;
   Ok: UpgradeToRequestId;
 };
type UpgradeToRequestId = nat;
type UpgradeToRequest = 
 record {
   args: blob;
   canister_id: principal;
   hash: blob;
   mode: canister_install_mode;
   parameters: opt vec record {
                         text;
                         ICRC16;
                       };
   restart: bool;
   snapshot: bool;
   stop: bool;
   timeout: nat;
 };
type UpgradeToError = 
 variant {
   Generic: text;
   InvalidPayment;
   Unauthorized;
   WasmUnavailable;
 };
type UpgradeFinishedResult = 
 variant {
   Failed: record {
             nat;
             text;
           };
   InProgress: nat;
   Success: nat;
 };
type TransactionRange = 
 record {
   length: nat;
   start: nat;
 };
type Tip = 
 record {
   hash_tree: blob;
   last_block_hash: blob;
   last_block_index: blob;
 };
type TimerId = nat;
type TimerDiagnostics = 
 record {
   currentTime: Time;
   lastExecutionDelta: int;
   lockStatus: opt Time;
   nextExecutionDelta: opt int;
   overdueActions: nat;
   pendingActions: nat;
   systemTimerStatus: opt TimerId;
   totalActions: nat;
 };
type Time__2 = int;
type Time = nat;
type StopCanisterResult = 
 variant {
   Err: StopCanisterError;
   Ok: nat;
 };
type StopCanisterRequest = 
 record {
   canister_id: principal;
   timeout: nat;
 };
type StopCanisterError = 
 variant {
   Generic: text;
   NotFound;
   Unauthorized;
 };
type StartCanisterResult = 
 variant {
   Err: StartCanisterError;
   Ok: nat;
 };
type StartCanisterRequest = 
 record {
   canister_id: principal;
   timeout: nat;
 };
type StartCanisterError = 
 variant {
   Generic: text;
   NotFound;
   Unauthorized;
 };
type RevertSnapshotResult = 
 variant {
   Err: RevertSnapshotError;
   Ok: nat;
 };
type RevertSnapshotRequest = 
 record {
   canister_id: principal;
   restart: bool;
   snapshot_id: blob;
 };
type RevertSnapshotError = 
 variant {
   Generic: text;
   NotFound;
   TooManyRequests;
   Unauthorized;
 };
type Result_7 = 
 variant {
   err: text;
   ok: vec CanisterCycleInfo;
 };
type Result_6 = 
 variant {
   err: text;
   ok: vec principal;
 };
type Result_5 = 
 variant {
   err: text;
   ok: CycleJobStatus;
 };
type Result_4 = 
 variant {
   err: text;
   ok: nat;
 };
type Result_3 = 
 variant {
   err: text;
   ok: principal;
 };
type Result_2 = 
 variant {
   err: text;
   ok: ResourceServer;
 };
type Result_1 = 
 variant {
   err: text;
   ok;
 };
type Result = 
 variant {
   err: text;
   ok: text;
 };
type ResourceServer = 
 record {
   accepted_payment_canisters: vec principal;
   frontend_host: opt text;
   logo_uri: text;
   name: text;
   owner: principal;
   resource_server_id: text;
   scopes: vec record {
                 text;
                 text;
               };
   service_principals: vec principal;
   status: variant {
             active;
             pending;
           };
   uris: vec text;
 };
type RegisterResourceServerArgs = 
 record {
   accepted_payment_canisters: vec principal;
   frontend_host: opt text;
   initial_service_principal: principal;
   logo_uri: text;
   name: text;
   scopes: vec record {
                 text;
                 text;
               };
   uris: vec text;
 };
type ReconstitutionTrace = 
 record {
   actionsRestored: nat;
   errors: vec text;
   migratedFrom: text;
   migratedTo: text;
   timersRestored: nat;
   timestamp: Time;
   validationPassed: bool;
 };
type OrchestrationEventType = 
 variant {
   canister_started;
   canister_stopped;
   configuration_changed;
   snapshot_cleaned;
   snapshot_created;
   snapshot_requested;
   snapshot_revert_requested;
   snapshot_reverted;
   upgrade_finished;
   upgrade_initiated;
 };
type OrchestrationEvent = 
 record {
   canister_id: principal;
   details: ICRC16;
   event_type: OrchestrationEventType;
   id: nat;
   timestamp: nat;
 };
type InternalDeployRequest = 
 record {
   hash: blob;
   namespace: text;
   owner: principal;
 };
type InitArgs = record {};
type InitArgList = 
 record {
   expectedExecutionTime: Time;
   initialTimers: vec record {
                        ActionId;
                        Action;
                      };
   lastActionIdReported: opt nat;
   lastCycleReport: opt nat;
   lastExecutionTime: Time;
   maxExecutions: opt nat;
   nextActionId: nat;
   nextCycleActionId: opt nat;
 };
type ICRC16__1 = 
 variant {
   Array: vec ICRC16__1;
   Blob: blob;
   Bool: bool;
   Bytes: vec nat8;
   Class: vec ICRC16Property__1;
   Float: float64;
   Floats: vec float64;
   Int: int;
   Int16: int16;
   Int32: int32;
   Int64: int64;
   Int8: int8;
   Map: ICRC16Map__1;
   Nat: nat;
   Nat16: nat16;
   Nat32: nat32;
   Nat64: nat64;
   Nat8: nat8;
   Nats: vec nat;
   Option: opt ICRC16__1;
   Principal: principal;
   Set: vec ICRC16__1;
   Text: text;
   ValueMap: vec record {
                   ICRC16__1;
                   ICRC16__1;
                 };
 };
type ICRC16Property__1 = 
 record {
   immutable: bool;
   name: text;
   value: ICRC16__1;
 };
type ICRC16Property = 
 record {
   immutable: bool;
   name: text;
   value: ICRC16;
 };
type ICRC16Map__1 = 
 vec record {
       text;
       ICRC16__1;
     };
type ICRC16Map = 
 vec record {
       text;
       ICRC16;
     };
type ICRC16 = 
 variant {
   Array: vec ICRC16;
   Blob: blob;
   Bool: bool;
   Bytes: vec nat8;
   Class: vec ICRC16Property;
   Float: float64;
   Floats: vec float64;
   Int: int;
   Int16: int16;
   Int32: int32;
   Int64: int64;
   Int8: int8;
   Map: vec record {
              text;
              ICRC16;
            };
   Nat: nat;
   Nat16: nat16;
   Nat32: nat32;
   Nat64: nat64;
   Nat8: nat8;
   Nats: vec nat;
   Option: opt ICRC16;
   Principal: principal;
   Set: vec ICRC16;
   Text: text;
   ValueMap: vec record {
                   ICRC16;
                   ICRC16;
                 };
 };
type ICRC120Canister = 
 service {
   /// * [OWNER ONLY] Add a principal as a controller to a managed canister.
   ///    * This is useful for manually fixing controller issues or adding the orchestrator
   ///    * itself as a controller for direct management.
   add_controller_to_canister: (canister_id: principal, new_controller:
    principal) -> (Result_1);
   cancel_actions_by_filter: (filter: ActionFilter) -> (CancellationResult);
   cancel_actions_by_ids: (ids: vec nat) -> (CancellationResult);
   /// * [NEW] Get detailed cycle information for all managed canisters.
   ///    * This is an UPDATE call that actually queries each canister's status.
   check_all_canister_cycles: () -> (Result_7);
   clear_reconstitution_traces: () -> ();
   /// * Debug function to help troubleshoot canister tracking issues
   debug_canister_info: (namespace: text) ->
    (record {
       caller_principal: principal;
       canister_deployment_types: vec record {
                                        text;
                                        CanisterDeploymentType;
                                      };
       canister_owners: vec record {
                              principal;
                              principal;
                            };
       canisters: vec principal;
     }) query;
   /// * The primary entry point for the owner to debug/fix bad installs.
   deploy_or_upgrade: (request: DeployOrUpgradeRequest) -> (Result_3);
   emergency_clear_all_timers: () -> (nat);
   force_release_lock: () -> (opt Time__2);
   force_system_timer_cancel: () -> (bool);
   get_actions_by_filter: (filter: ActionFilter) -> (vec ActionDetail) query;
   get_all_canister_cycles: () -> (Result_7) query;
   /// * [PUBLIC] Get the current auth server configuration.
   ///    * This helps with debugging and verification of the setup.
   get_auth_server_id: () -> (opt principal) query;
   /// * [OWNER ONLY] Get the list of controllers for a managed canister.
   get_canister_controllers: (canister_id: principal) -> (Result_6);
   get_canister_id: (namespace: text, wasm_id: text) -> (opt principal) query;
   get_canisters: (namespace: text) -> (vec principal) query;
   get_cycle_job_status: () -> (Result_5) query;
   /// * Returns the current configuration for the automated cycle top-up feature.
   get_cycle_top_up_config: () -> (CycleTopUpConfig) query;
   get_env_requirements: () ->
    (variant {
       v1:
        record {
          configuration: vec EnvConfig;
          dependencies: vec EnvDependency;
        };}) query;
   get_latest_reconstitution_trace: () -> (opt ReconstitutionTrace) query;
   /// * [NEW] Get the current orchestrator's cycle balance.
   get_orchestrator_cycles: () -> (Result_4) query;
   get_reconstitution_traces: () -> (vec ReconstitutionTrace) query;
   get_timer_diagnostics: () -> (TimerDiagnostics) query;
   get_tip: () -> (Tip) query;
   hello: () -> (text);
   icrc120_clean_snapshot: (requests: vec CleanSnapshotRequest) ->
    (vec CleanSnapshotResult);
   icrc120_config_canister: (requests: vec ConfigCanisterRequest) ->
    (vec ConfigCanisterResult);
   icrc120_create_snapshot: (requests: vec CreateSnapshotRequest) ->
    (vec CreateSnapshotResult);
   icrc120_get_events: (input:
    record {
      filter: opt GetEventsFilter;
      prev: opt blob;
      take: opt nat;
    }) -> (vec OrchestrationEvent) query;
   icrc120_metadata: () -> (ICRC16Map);
   icrc120_revert_snapshot: (requests: vec RevertSnapshotRequest) ->
    (vec RevertSnapshotResult);
   icrc120_start_canister: (requests: vec StartCanisterRequest) ->
    (vec StartCanisterResult);
   icrc120_stop_canister: (requests: vec StopCanisterRequest) ->
    (vec StopCanisterResult);
   icrc120_upgrade_finished: () -> (UpgradeFinishedResult);
   icrc120_upgrade_to: (requests: vec UpgradeToRequest) ->
    (vec UpgradeToResult);
   icrc3_get_archives: (args: GetArchivesArgs) -> (GetArchivesResult) query;
   icrc3_get_blocks: (args: GetBlocksArgs) -> (GetBlocksResult) query;
   icrc3_get_tip_certificate: () -> (opt DataCertificate) query;
   icrc3_supported_block_types: () -> (vec BlockType) query;
   /// * [INTERNAL] A privileged endpoint for the MCP Registry, used for automated global deployments.
   internal_deploy_or_upgrade: (request: InternalDeployRequest) -> ();
   provision_instance: (namespace: text, wasmId: text) -> (Result_3);
   /// * [PUBLIC] Manually register a canister as an OAuth resource server.
   ///    * This can be used if automatic registration fails or for manual configuration.
   register_oauth_resource: (canister_id: principal, args:
    RegisterResourceServerArgs) -> (Result_2);
   /// * [OWNER ONLY] Remove a principal from a canister's controller list.
   ///    * Use with caution - removing all controllers will make the canister unmanageable.
   remove_controller_from_canister: (canister_id: principal,
    controller_to_remove: principal) -> (Result_1);
   set_auth_server_id: (authServerId: principal) -> (Result_1);
   set_canister_owner: (canister_id: principal, new_owner: principal) ->
    (Result_1);
   /// * Sets the configuration for the automated cycle top-up feature.
   ///    * This function is restricted to the owner of the orchestrator canister.
   ///    * It will reschedule or remove the timer job based on the new settings.
   set_cycle_top_up_config: (config: CycleTopUpConfig) -> (Result_1);
   set_deployment_type: (namespace: text, wasm_id: text, deployment_type:
    CanisterDeploymentType) -> (Result_1);
   set_mcp_registry_id: (registryId: principal) -> (Result_1);
   set_usage_tracker_id: (usageTrackerId: principal) -> (Result_1);
   /// * [NEW] Manually trigger a cycle check and top-up for all managed canisters.
   ///    * This is useful for testing and debugging the automated cycle management system.
   trigger_manual_cycle_top_up: () -> (Result);
   validate_timer_state: () -> (vec text) query;
 };
type GetTransactionsResult = 
 record {
   archived_blocks: vec ArchivedTransactionResponse;
   blocks: vec record {
                 block: Value;
                 id: nat;
               };
   log_length: nat;
 };
type GetTransactionsFn = func (vec TransactionRange) ->
                          (GetTransactionsResult) query;
type GetEventsFilter = 
 record {
   canister: opt principal;
   end_time: opt nat;
   event_types: opt vec OrchestrationEventType;
   start_time: opt nat;
 };
type GetBlocksResult = 
 record {
   archived_blocks: vec ArchivedTransactionResponse;
   blocks: vec record {
                 block: Value;
                 id: nat;
               };
   log_length: nat;
 };
type GetBlocksArgs = vec TransactionRange;
type GetArchivesResultItem = 
 record {
   canister_id: principal;
   end: nat;
   start: nat;
 };
type GetArchivesResult = vec GetArchivesResultItem;
type GetArchivesArgs = record {from: opt principal;};
type EnvDependency = 
 record {
   canister_name: text;
   current_value: opt principal;
   key: text;
   required: bool;
   setter: text;
 };
type EnvConfig = 
 record {
   current_value: opt text;
   key: text;
   required: bool;
   setter: text;
   value_type: text;
 };
type DeployOrUpgradeRequest = 
 record {
   args: blob;
   deployment_type: CanisterDeploymentType;
   hash: blob;
   mode: canister_install_mode;
   namespace: text;
   parameters: opt vec record {
                         text;
                         ICRC16__1;
                       };
   restart: bool;
   snapshot: bool;
   stop: bool;
   timeout: nat;
 };
type DataCertificate = 
 record {
   certificate: blob;
   hash_tree: blob;
 };
type CycleTopUpConfig = 
 record {
   amount: nat;
   enabled: bool;
   interval_seconds: nat;
   threshold: nat;
 };
type CycleJobStatus = 
 record {
   enabled: bool;
   job_action_id: opt nat;
   job_scheduled: bool;
   last_check: opt int;
   next_check: opt int;
   orchestrator_balance: nat;
 };
type CreateSnapshotResult = 
 variant {
   Err: CreateSnapshotError;
   Ok: nat;
 };
type CreateSnapshotRequest = 
 record {
   canister_id: principal;
   restart: bool;
 };
type CreateSnapshotError = 
 variant {
   Generic: text;
   NotFound;
   Unauthorized;
 };
type ConfigCanisterResult = 
 variant {
   Err: ConfigCanisterError;
   Ok: nat;
 };
type ConfigCanisterRequest = 
 record {
   canister_id: principal;
   configs: vec record {
                  text;
                  ICRC16;
                };
 };
type ConfigCanisterError = 
 variant {
   Generic: text;
   InvalidConfig: text;
   Unauthorized;
 };
type CleanSnapshotResult = 
 variant {
   Err: CleanSnapshotError;
   Ok: nat;
 };
type CleanSnapshotRequest = 
 record {
   canister_id: principal;
   snapshot_id: blob;
 };
type CleanSnapshotError = 
 variant {
   Generic: text;
   NotFound;
   TooManyRequests;
   Unauthorized;
 };
type CanisterDeploymentType = 
 variant {
   global;
   provisioned;
 };
type CanisterCycleInfo = 
 record {
   canister_id: principal;
   cycles: nat;
   namespace: text;
   needs_top_up: bool;
 };
type CancellationResult = 
 record {
   cancelled: vec ActionId;
   errors: vec record {
                 nat;
                 text;
               };
   notFound: vec nat;
 };
type BlockType = 
 record {
   block_type: text;
   url: text;
 };
type ArchivedTransactionResponse = 
 record {
   args: vec TransactionRange;
   callback: GetTransactionsFn;
 };
type ActionId = 
 record {
   id: nat;
   time: Time;
 };
type ActionFilter = 
 variant {
   All;
   ByActionId: nat;
   ByRetryCount: nat;
   ByTimeRange: record {
                  Time;
                  Time;
                };
   ByType: text;
 };
type ActionDetail = 
 record {
   ActionId;
   Action;
 };
type Action = 
 record {
   aSync: opt nat;
   actionType: text;
   params: blob;
   retries: nat;
 };
service : (args: opt
                  record {
                    icrc120Args: opt InitArgs;
                    ttArgs: opt InitArgList;
                  }) -> ICRC120Canister
