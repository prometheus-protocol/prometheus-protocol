type UsageTracker = 
 service {
   add_approved_wasm_hash: (wasm_id: text) -> (Result);
   get_all_server_metrics: () ->
    (vec record {
           text;
           ServerMetricsShared;
         }) query;
   get_and_clear_logs: () -> (Result_2);
   get_app_metrics: (canister_id: principal) -> (opt AppMetrics) query;
   get_env_requirements: () ->
    (variant {
       v1:
        record {
          configuration: vec EnvConfig;
          dependencies: vec EnvDependency;
        };}) query;
   get_metrics_for_server: (wasm_id: text) -> (opt ServerMetricsShared) query;
   get_namespace_metrics: (namespace: text) -> (opt NamespaceMetrics) query;
   /// * Get detailed namespace metrics including per-tool invocation counts.
   ///    * Returns aggregated tool usage across all WASM versions of the namespace.
   get_namespace_metrics_detailed: (namespace: text) ->
    (opt NamespaceMetricsDetailed) query;
   /// * Get tool invocations for a specific namespace.
   ///    * Returns an array of tools with their aggregated invocation counts.
   get_namespace_tools: (namespace: text) -> (vec ToolMetrics) query;
   /// * Gets all WASM IDs currently registered for a namespace.
   get_namespace_wasms: (namespace: text) -> (vec text) query;
   get_owner: () -> (principal) query;
   get_payout_canister: () -> (opt principal) query;
   is_wasm_hash_approved: (wasm_id: text) -> (bool) query;
   /// * Lists all WASM IDs that have historical data in aggregated_metrics.
   ///    * This is useful for discovering which historical WASMs can be registered with namespaces.
   list_all_wasm_ids: () -> (vec record {
                                   text;
                                   nat;
                                   nat;
                                 }) query;
   log_call: (stats: UsageStats) -> (Result);
   /// * Rebuilds the namespace_to_wasms mapping from existing canister_to_wasm and canister_to_namespace data.
   ///    * This is useful for migrating existing data or recovering from data inconsistencies.
   ///    * Should be called by the owner after upgrading to ensure all historical WASMs are tracked.
   rebuild_namespace_wasm_mappings: () -> (Result_1);
   /// * Registers the namespace for a canister. This should be called by the orchestrator
   ///    * when a new canister is provisioned or when an existing canister is upgraded.
   register_canister_namespace: (canister_id: principal, namespace: text) ->
    (Result);
   /// * Manually registers a historical WASM ID with a namespace.
   ///    * This is useful for recovering historical data from WASM versions that are no longer active.
   ///    *
   ///    * Use case: If a canister was upgraded from v1 (wasm_id_1) to v2 (wasm_id_2), and you want to
   ///    * include the v1 users in the namespace metrics, call this function with wasm_id_1.
   ///    *
   ///    * The WASM ID must exist in aggregated_metrics (meaning it has historical usage data).
   register_historical_wasm: (namespace: text, wasm_id: text) -> (Result_1);
   remove_approved_wasm_hash: (wasm_id: text) -> (Result);
   seed_log: (canister_id: principal, wasm_id: text, stats: UsageStats) ->
    (Result);
   set_orchestrator_canister: (canister_id: principal) -> (Result);
   set_owner: (new_owner: principal) -> (Result);
   set_payout_canister: (canister_id: principal) -> (Result);
   set_registry_canister: (canister_id: principal) -> (Result);
 };
type UsageStats = 
 record {
   activity: vec CallerActivity;
   end_timestamp_ns: Time;
   start_timestamp_ns: Time;
 };
type ToolMetrics = 
 record {
   tool_id: text;
   total_invocations: nat;
 };
type Time = int;
type ServerMetricsShared = 
 record {
   invocations_by_tool: vec record {
                              text;
                              nat;
                            };
   invocations_by_user: vec record {
                              principal;
                              nat;
                            };
   total_invocations: nat;
 };
type Result_2 = 
 variant {
   err: text;
   ok: vec LogEntry;
 };
type Result_1 = 
 variant {
   err: text;
   ok: text;
 };
type Result = 
 variant {
   err: text;
   ok;
 };
type NamespaceMetricsDetailed = 
 record {
   anonymous_invocations: nat;
   authenticated_unique_users: nat;
   namespace: text;
   tools: vec ToolMetrics;
   total_instances: nat;
   total_invocations: nat;
 };
type NamespaceMetrics = 
 record {
   anonymous_invocations: nat;
   authenticated_unique_users: nat;
   namespace: text;
   total_instances: nat;
   total_invocations: nat;
   total_tools: nat;
 };
type LogEntry = 
 record {
   canister_id: principal;
   stats: UsageStats;
   timestamp: Time;
   wasm_id: text;
 };
type EnvDependency = 
 record {
   canister_name: text;
   current_value: opt principal;
   key: text;
   required: bool;
   setter: text;
 };
type EnvConfig = 
 record {
   current_value: opt text;
   key: text;
   required: bool;
   setter: text;
   value_type: text;
 };
type CallerActivity = 
 record {
   call_count: nat;
   caller: principal;
   tool_id: text;
 };
type AppMetrics = 
 record {
   anonymous_invocations: nat;
   authenticated_unique_users: nat;
   total_invocations: nat;
   total_tools: nat;
 };
/// * The UsageTracker canister serves as a high-throughput logbook for the "Proof-of-Use" system.
///  * It accepts usage statistics from approved MCP server canisters and makes them available to a designated payout canister.
service : () -> UsageTracker
