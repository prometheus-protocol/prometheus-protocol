type VerifierProfile = 
 record {
   reputation_score: nat;
   total_earnings: Balance;
   total_verifications: nat;
 };
type VerificationJobAssignment = 
 record {
   bounty_id: BountyId;
   build_config: ICRC16Map;
   commit_hash: text;
   expires_at: Timestamp;
   repo: text;
   wasm_id: text;
 };
type VerificationJob = 
 record {
   assigned_count: nat;
   bounty_ids: vec BountyId;
   build_config: ICRC16Map;
   commit_hash: text;
   created_at: Timestamp;
   repo: text;
   required_verifiers: nat;
   wasm_id: text;
 };
type TokenId = text;
type Timestamp = int;
type Result_3 = 
 variant {
   err: text;
   ok: text;
 };
type Result_2 = 
 variant {
   err: text;
   ok: VerificationJobAssignment;
 };
type Result_1 = 
 variant {
   err: text;
   ok: principal;
 };
type Result = 
 variant {
   err: text;
   ok;
 };
type ICRC16Property = 
 record {
   immutable: bool;
   name: text;
   value: ICRC16;
 };
type ICRC16Map = 
 vec record {
       text;
       ICRC16;
     };
type ICRC16 = 
 variant {
   Array: vec ICRC16;
   Blob: blob;
   Bool: bool;
   Bytes: vec nat8;
   Class: vec ICRC16Property;
   Float: float64;
   Floats: vec float64;
   Int: int;
   Int16: int16;
   Int32: int32;
   Int64: int64;
   Int8: int8;
   Map: vec record {
              text;
              ICRC16;
            };
   Nat: nat;
   Nat16: nat16;
   Nat32: nat32;
   Nat64: nat64;
   Nat8: nat8;
   Nats: vec nat;
   Option: opt ICRC16;
   Principal: principal;
   Set: vec ICRC16;
   Text: text;
   ValueMap: vec record {
                   ICRC16;
                   ICRC16;
                 };
 };
type EnvDependency = 
 record {
   canister_name: text;
   current_value: opt principal;
   key: text;
   required: bool;
   setter: text;
 };
type EnvConfig = 
 record {
   current_value: opt text;
   key: text;
   required: bool;
   setter: text;
   value_type: text;
 };
type BountyLock = 
 record {
   claimant: principal;
   expires_at: Timestamp;
   stake_amount: Balance;
   stake_token_id: TokenId;
 };
type BountyId = nat;
type Balance = nat;
type AuditHub = 
 service {
   /// * Add a new verification job to the queue.
   ///    * Called by mcp_registry when a new WASM is registered.
   ///    * Only the registry canister can call this function.
   add_verification_job: (wasm_id: text, repo: text, commit_hash: text,
    build_config: ICRC16Map, required_verifiers: nat, bounty_ids:
    vec BountyId) -> (Result);
   admin_add_bounties_to_job: (wasm_id: text, audit_type: text,
    additional_bounty_ids: vec nat) -> (Result);
   cleanup_expired_lock: (bounty_id: BountyId) -> (Result);
   debug_get_bounty: (bounty_id: nat) -> (text);
   /// * Deposit tokens as stake to become an eligible auditor.
   ///    * The caller must have already approved this canister to spend tokens on their behalf.
   ///    * @param token_id - The ledger canister ID (as Principal text) of the token to deposit (e.g., USDC, ICP)
   ///    * @param amount - The amount to deposit (in token's smallest unit)
   deposit_stake: (token_id: TokenId, amount: Balance) -> (Result);
   /// * Generate a new API key for the verifier to use in their bot.
   ///    * Called by the verifier principal (authenticated via Internet Identity in UI).
   generate_api_key: () -> (Result_3);
   /// * Get available balance by audit_type.
   ///    * Looks up the token_id from the stake_requirements for this audit type.
   get_available_balance_by_audit_type: (verifier: principal, audit_type:
    text) -> (Balance) query;
   get_bounty_lock: (bounty_id: BountyId) -> (opt BountyLock) query;
   get_env_requirements: () ->
    (variant {
       v1:
        record {
          configuration: vec EnvConfig;
          dependencies: vec EnvDependency;
        };}) query;
   get_owner: () -> (principal) query;
   /// * Get the stake requirement for a specific audit type.
   ///    * Returns (token_id, amount) tuple.
   get_stake_requirement: (audit_type: text) ->
    (opt record {
           TokenId;
           Balance;
         }) query;
   get_staked_balance: (verifier: principal, token_id: TokenId) ->
    (Balance) query;
   /// * Get verifier profile with balances for a specific token.
   ///    * @param verifier - The principal of the verifier
   ///    * @param token_id - The ledger canister ID (as Principal text) of the token to query
   get_verifier_profile: (verifier: principal, token_id: TokenId) ->
    (VerifierProfile) query;
   /// * Check if a verifier has any active (non-expired) bounty locks.
   ///    * This is used by the registry to authorize API-key-based attestations.
   ///    * @param verifier - The principal of the verifier to check
   ///    * @returns true if the verifier has at least one active lock, false otherwise
   has_active_bounty_lock: (verifier: principal) -> (bool) query;
   is_bounty_ready_for_collection: (bounty_id: BountyId, potential_claimant:
    principal) -> (bool) query;
   /// * List all API keys for the authenticated verifier.
   list_api_keys: () -> (vec ApiCredential);
   /// * Get all currently assigned jobs (for debugging/monitoring).
   list_assigned_jobs: () -> (vec record {
                                    BountyId;
                                    AssignedJob;
                                  }) query;
   /// * Get all pending verification jobs (for debugging/monitoring).
   list_pending_jobs: () -> (vec record {
                                   text;
                                   VerificationJob;
                                 }) query;
   /// * Mark a verification job as complete.
   ///    * Called by mcp_registry when a WASM verification or audit is finalized.
   ///    * Only the registry canister can call this function.
   ///    * @param wasm_id - The WASM ID
   ///    * @param audit_type - The audit type (e.g., "build_reproducibility_v1", "tools_v1")
   mark_verification_complete: (wasm_id: text, audit_type: text) -> (Result);
   /// * Release a job assignment when verification is complete or expired.
   ///    * Can be called by the verifier or by cleanup processes.
   release_job_assignment: (bounty_id: BountyId) -> (Result);
   release_stake: (bounty_id: BountyId) -> (Result);
   /// * Request a verification job assignment.
   ///    * Called by verifier bots using their API key.
   ///    * Returns a job assignment with bounty_id, or an error if no jobs available.
   ///    *
   ///    * PERFORMANCE OPTIMIZATION:
   ///    * Instead of checking participation for each job individually (N jobs × M verifiers = lots of calls),
   ///    * we batch-check participation for ALL jobs that need verifiers upfront (M verifiers × 1 batch each).
   ///    * This dramatically reduces inter-canister calls to mcp_registry.
   request_verification_job_with_api_key: (api_key: text) -> (Result_2);
   /// * Allows a verifier to stake tokens to reserve a bounty (1-hour lock).
   ///    * Can be called directly by the verifier principal.
   ///    * @param bounty_id - The bounty to reserve
   ///    * @param audit_type - The audit type (e.g., "tools_v1", "build_reproducibility_v1")
   reserve_bounty: (bounty_id: BountyId, audit_type: text) -> (Result);
   /// * Reserve a bounty using an API key (for bot authentication).
   ///    * The bot passes its API key, and we resolve it to the verifier principal.
   ///    * @param api_key - The verifier's API key
   ///    * @param bounty_id - The bounty to reserve
   ///    * @param audit_type - The audit type (e.g., "tools_v1", "build_reproducibility_v1")
   reserve_bounty_with_api_key: (api_key: text, bounty_id: BountyId,
    audit_type: text) -> (Result);
   /// * Revoke an API key (makes it inactive).
   revoke_api_key: (api_key: text) -> (Result);
   set_bounty_sponsor_canister_id: (bounty_sponsor_id: principal) -> (Result);
   set_owner: (new_owner: principal) -> (Result);
   set_registry_canister_id: (registry_id: principal) -> (Result);
   /// * Set the stake requirement for a specific audit type.
   ///    * @param audit_type - The audit type (e.g., "tools_v1", "build_reproducibility_v1")
   ///    * @param token_id - The ledger canister ID for the staking token
   ///    * @param amount - The stake amount required (in token's smallest unit)
   set_stake_requirement: (audit_type: text, token_id: TokenId, amount:
    Balance) -> (Result);
   /// * Called by the registry when a verifier was on the losing side of consensus.
   ///    * Slashes their stake and penalizes reputation (they provided incorrect verification).
   slash_stake_for_incorrect_consensus: (bounty_id: BountyId) -> (Result);
   /// * Validate an API key and return the associated verifier principal.
   ///    * Used by the verifier bot to authenticate reserve_bounty requests.
   validate_api_key: (api_key: text) -> (Result_1) query;
   /// * Withdraw tokens from the verifier's available balance (not currently staked).
   ///    * The withdrawal amount will have the token's fee deducted from it during transfer.
   ///    * @param token_id - The ledger canister ID (as Principal text) of the token to withdraw
   ///    * @param amount - The amount to withdraw (in token's smallest unit) - this is what the user will receive
   withdraw_stake: (token_id: TokenId, amount: Balance) -> (Result);
 };
type AssignedJob = 
 record {
   assigned_at: Timestamp;
   bounty_id: BountyId;
   expires_at: Timestamp;
   verifier: principal;
   wasm_id: text;
 };
type ApiCredential = 
 record {
   api_key: text;
   created_at: Timestamp;
   is_active: bool;
   last_used: opt Timestamp;
   verifier_principal: principal;
 };
service : () -> AuditHub
