type VerifierProfile = 
 record {
   reputation_score: nat;
   total_earnings: Balance;
   total_verifications: nat;
 };
type VerificationJobAssignment = 
 record {
   bounty_id: BountyId;
   build_config: ICRC16Map;
   commit_hash: text;
   expires_at: Timestamp__1;
   repo: text;
   wasm_id: text;
 };
type VerificationJob = 
 record {
   assigned_count: nat;
   audit_type: text;
   bounty_ids: vec BountyId;
   build_config: ICRC16Map;
   commit_hash: text;
   completed_count: nat;
   created_at: Timestamp__1;
   creator: principal;
   repo: text;
   required_verifiers: nat;
   wasm_id: text;
 };
type TreasuryError = 
 variant {
   LedgerTrap: text;
   NotOwner;
   TransferFailed: TransferError;
 };
type TransferError = 
 variant {
   BadBurn: record {min_burn_amount: nat;};
   BadFee: record {expected_fee: nat;};
   CreatedInFuture: record {ledger_time: Timestamp;};
   Duplicate: record {duplicate_of: nat;};
   GenericError: record {
                   error_code: nat;
                   message: text;
                 };
   InsufficientFunds: record {balance: nat;};
   TemporarilyUnavailable;
   TooOld;
 };
type TokenId = text;
type Timestamp__1 = int;
type Timestamp = nat64;
type Subaccount = blob;
type RunBountyResult__1 = 
 record {
   metadata: ICRC16__1;
   result: variant {
             Invalid;
             Valid;
           };
   trx_id: opt nat;
 };
type RunBountyResult = 
 record {
   metadata: ICRC16;
   result: variant {
             Invalid;
             Valid;
           };
   trx_id: opt nat;
 };
type Result_5 = 
 variant {
   err: text;
   ok: vec nat;
 };
type Result_4 = 
 variant {
   err: text;
   ok: text;
 };
type Result_3 = 
 variant {
   err: text;
   ok: VerificationJobAssignment;
 };
type Result_2 = 
 variant {
   err: text;
   ok: principal;
 };
type Result_1 = 
 variant {
   err: TreasuryError;
   ok: nat;
 };
type Result = 
 variant {
   err: text;
   ok;
 };
type ListBountiesFilter = 
 variant {
   claimed: bool;
   claimed_by: Account__1;
   created_after: nat;
   created_before: nat;
   metadata: ICRC16Map__2;
   validation_canister: principal;
 };
type ICRC16__1 = 
 variant {
   Array: vec ICRC16__1;
   Blob: blob;
   Bool: bool;
   Bytes: vec nat8;
   Class: vec ICRC16Property__1;
   Float: float64;
   Floats: vec float64;
   Int: int;
   Int16: int16;
   Int32: int32;
   Int64: int64;
   Int8: int8;
   Map: ICRC16Map__2;
   Nat: nat;
   Nat16: nat16;
   Nat32: nat32;
   Nat64: nat64;
   Nat8: nat8;
   Nats: vec nat;
   Option: opt ICRC16__1;
   Principal: principal;
   Set: vec ICRC16__1;
   Text: text;
   ValueMap: vec record {
                   ICRC16__1;
                   ICRC16__1;
                 };
 };
type ICRC16Property__1 = 
 record {
   immutable: bool;
   name: text;
   value: ICRC16__1;
 };
type ICRC16Property = 
 record {
   immutable: bool;
   name: text;
   value: ICRC16;
 };
type ICRC16Map__2 = 
 vec record {
       text;
       ICRC16__1;
     };
type ICRC16Map = 
 vec record {
       text;
       ICRC16;
     };
type ICRC16 = 
 variant {
   Array: vec ICRC16;
   Blob: blob;
   Bool: bool;
   Bytes: vec nat8;
   Class: vec ICRC16Property;
   Float: float64;
   Floats: vec float64;
   Int: int;
   Int16: int16;
   Int32: int32;
   Int64: int64;
   Int8: int8;
   Map: vec record {
              text;
              ICRC16;
            };
   Nat: nat;
   Nat16: nat16;
   Nat32: nat32;
   Nat64: nat64;
   Nat8: nat8;
   Nats: vec nat;
   Option: opt ICRC16;
   Principal: principal;
   Set: vec ICRC16;
   Text: text;
   ValueMap: vec record {
                   ICRC16;
                   ICRC16;
                 };
 };
type EnvDependency = 
 record {
   canister_name: text;
   current_value: opt principal;
   key: text;
   required: bool;
   setter: text;
 };
type EnvConfig = 
 record {
   current_value: opt text;
   key: text;
   required: bool;
   setter: text;
   value_type: text;
 };
type CreateBountyResult = 
 variant {
   Error: variant {
            Generic: text;
            InsufficientAllowance;
          };
   Ok: record {
         bounty_id: nat;
         trx_id: opt nat;
       };
 };
type CreateBountyRequest = 
 record {
   bounty_id: opt nat;
   bounty_metadata: ICRC16Map__2;
   challenge_parameters: ICRC16__1;
   start_date: opt nat;
   timeout_date: nat;
   validation_canister_id: principal;
 };
type ClaimRecord__1 = 
 record {
   caller: principal;
   claim_account: opt Account__1;
   claim_id: nat;
   claim_metadata: ICRC16Map__2;
   result: opt RunBountyResult__1;
   submission: ICRC16__1;
   time_submitted: nat;
 };
type ClaimRecord = 
 record {
   caller: principal;
   claim_account: opt Account__1;
   claim_id: nat;
   claim_metadata: ICRC16Map;
   result: opt RunBountyResult;
   submission: ICRC16;
   time_submitted: nat;
 };
type Bounty__1 = 
 record {
   bounty_id: nat;
   bounty_metadata: ICRC16Map__2;
   challenge_parameters: ICRC16__1;
   claimed: opt nat;
   claimed_date: opt nat;
   claims: vec ClaimRecord__1;
   created: nat;
   creator: principal;
   payout_fee: nat;
   timeout_date: opt nat;
   token_amount: nat;
   token_canister_id: principal;
   validation_call_timeout: nat;
   validation_canister_id: principal;
 };
type BountySubmissionResult = 
 variant {
   Error: variant {
            Generic: text;
            NoMatch;
            PayoutFailed: TransferError;
          };
   Ok: record {
         claim_id: nat;
         result: opt RunBountyResult__1;
       };
 };
type BountySubmissionRequest = 
 record {
   account: opt Account__1;
   bounty_id: nat;
   submission: ICRC16__1;
 };
type BountyStatus = 
 variant {
   Claimed;
   Open;
 };
type BountyLock = 
 record {
   claimant: principal;
   expires_at: Timestamp__1;
   stake_amount: Balance;
   stake_token_id: TokenId;
 };
type BountyListingResponse = 
 variant {
   err: text;
   ok: vec Bounty;
 };
type BountyListingRequest = 
 record {
   filter: opt vec BountyFilter;
   prev: opt nat;
   take: opt nat;
 };
type BountyId = nat;
type BountyFilter = 
 variant {
   audit_type: text;
   creator: principal;
   status: BountyStatus;
   wasm_id: text;
 };
type Bounty = 
 record {
   bounty_id: nat;
   bounty_metadata: ICRC16Map;
   challenge_parameters: ICRC16;
   claimed: opt nat;
   claimed_date: opt nat;
   claims: vec ClaimRecord;
   created: nat;
   creator: principal;
   payout_fee: nat;
   timeout_date: opt nat;
   token_amount: nat;
   token_canister_id: principal;
   validation_call_timeout: nat;
   validation_canister_id: principal;
 };
type Balance = nat;
type AuditHub = 
 service {
   /// * Add a new verification job to the queue.
   ///    * Called by mcp_registry when a new WASM is registered.
   ///    * Only the registry canister can call this function.
   add_verification_job: (wasm_id: text, repo: text, commit_hash: text,
    build_config: ICRC16Map, audit_type: text, required_verifiers: nat,
    bounty_ids: vec BountyId) -> (Result);
   admin_add_bounties_by_queue_key: (queue_key: text, additional_bounty_ids:
    vec nat) -> (Result);
   admin_add_bounties_to_job: (wasm_id: text, audit_type: text,
    additional_bounty_ids: vec nat) -> (Result);
   /// * Add a verifier to the deny list (temporarily blocks them from receiving jobs).
   ///    * Use this for problematic nodes until they upgrade.
   admin_add_to_deny_list: (verifier: principal) -> (Result);
   /// * Admin method to manually add a verifier to job_verifier_assignments.
   ///    * Used for migration or manual fixes when verifiers have already participated but aren't tracked.
   ///    * @param queue_key - The job queue key (wasm_id::audit_type::timestamp)
   ///    * @param verifier - The verifier principal to add
   admin_add_verifier_to_job: (queue_key: text, verifier: principal) ->
    (Result);
   admin_claim_bounty_for_verifier: (bounty_id: BountyId, verifier:
    principal, wasm_id: text) -> (Result);
   /// * Admin function to clean up staked balances from deleted/non-existent bounties.
   ///    * This will check all bounty locks and return stakes to available for bounties that don't exist.
   admin_cleanup_orphaned_stakes: () -> (Result_4);
   admin_clear_bounty_verifier: (bounty_id: BountyId) -> (Result);
   /// * Admin function to manually fix a job's assigned_count
   ///    * Useful when locks are released but assigned_count wasn't decremented
   admin_fix_job_assigned_count: (queue_key: text, new_assigned_count:
    nat) -> (Result);
   admin_force_release_lock: (bounty_id: BountyId) -> (Result);
   /// * Remove a verifier from the deny list.
   admin_remove_from_deny_list: (verifier: principal) -> (Result);
   /// * Admin method to remove a verifier from job_verifier_assignments.
   ///    * Allows a verifier to retry a job they previously failed or released.
   ///    * @param queue_key - The job queue key (wasm_id::audit_type::timestamp)
   ///    * @param verifier - The verifier principal to remove
   admin_remove_verifier_from_job: (queue_key: text, verifier: principal) ->
    (Result);
   /// * Attach multiple bounties to a job in a single atomic operation.
   ///    * This prevents race conditions when creating multiple bounties concurrently.
   ///    * Can be called by bounty_sponsor or owner after creating bounties.
   attach_bounties_to_job: (wasm_id: text, audit_type: text, bounty_ids:
    vec nat) -> (Result);
   cleanup_expired_lock: (bounty_id: BountyId) -> (Result);
   /// * Create local bounties for a verification job.
   ///    * This enables local bounty management instead of relying on mcp_registry.
   ///    * Can be called by authorized canisters (registry, bounty_sponsor) or owner.
   ///    *
   ///    * @param wasm_id - The WASM ID
   ///    * @param audit_type - The audit type (e.g., "build_reproducibility_v1")
   ///    * @param num_bounties - Number of bounties to create
   ///    * @param reward_amount - Reward amount per bounty (in token atomic units)
   ///    * @param reward_token - Token canister ID for rewards
   ///    * @param timeout_date - Expiration timestamp for bounties
   create_local_bounties_for_job: (wasm_id: text, audit_type: text,
    num_bounties: nat, reward_amount: nat, reward_token: principal,
    timeout_date: int) -> (Result_5);
   /// * Deposit tokens as stake to become an eligible auditor.
   ///    * The caller must have already approved this canister to spend tokens on their behalf.
   ///    * @param token_id - The ledger canister ID (as Principal text) of the token to deposit (e.g., USDC, ICP)
   ///    * @param amount - The amount to deposit (in token's smallest unit)
   deposit_stake: (token_id: TokenId, amount: Balance) -> (Result);
   /// * Generate a new API key for the verifier to use in their bot.
   ///    * Called by the verifier principal (authenticated via Internet Identity in UI).
   generate_api_key: () -> (Result_4);
   /// * Get available balance by audit_type.
   ///    * Looks up the token_id from the stake_requirements for this audit type.
   get_available_balance_by_audit_type: (verifier: principal, audit_type:
    text) -> (Balance) query;
   /// * Get all bounties for a specific job by its queue key.
   ///    * Returns an empty array if the job doesn't exist.
   get_bounties_for_job: (queue_key: text) -> (vec Bounty) query;
   /// * Get all bounties and their locks for a specific job by its queue key.
   ///    * More efficient than fetching bounties and then fetching each lock separately.
   ///    * Returns tuple of (bounty, optional lock) for each bounty in the job.
   get_bounties_with_locks_for_job: (queue_key: text) ->
    (vec record {
           Bounty;
           opt BountyLock;
         }) query;
   get_bounty_lock: (bounty_id: BountyId) -> (opt BountyLock) query;
   /// * Get the current deny list.
   get_deny_list: () -> (vec principal) query;
   get_env_requirements: () ->
    (variant {
       v1:
        record {
          configuration: vec EnvConfig;
          dependencies: vec EnvDependency;
        };}) query;
   get_owner: () -> (principal) query;
   /// * Get a specific pending job by its queue key.
   ///    * Returns null if the job doesn't exist.
   get_pending_job: (queue_key: text) -> (opt VerificationJob) query;
   /// * Get the stake requirement for a specific audit type.
   ///    * Returns (token_id, amount) tuple.
   get_stake_requirement: (audit_type: text) ->
    (opt record {
           TokenId;
           Balance;
         }) query;
   get_staked_balance: (verifier: principal, token_id: TokenId) ->
    (Balance) query;
   /// * Get leaderboard of all verifiers sorted by total verifications.
   ///    * Returns an array of (Principal, VerifierProfile) tuples, sorted descending by total_verifications.
   ///    * Used for the verifier leaderboard UI.
   get_verifier_leaderboard: () ->
    (vec record {
           principal;
           VerifierProfile;
         }) query;
   /// * Get verifier profile with balances for a specific token.
   ///    * @param verifier - The principal of the verifier
   ///    * @param token_id - The ledger canister ID (as Principal text) of the token to query
   get_verifier_profile: (verifier: principal, token_id: TokenId) ->
    (VerifierProfile) query;
   /// * Check if a verifier has any active (non-expired) bounty locks.
   ///    * This is used by the registry to authorize API-key-based attestations.
   ///    * @param verifier - The principal of the verifier to check
   ///    * @returns true if the verifier has at least one active lock, false otherwise
   has_active_bounty_lock: (verifier: principal) -> (bool) query;
   icrc10_supported_standards: () ->
    (vec record {
           name: text;
           url: text;
         }) query;
   icrc127_create_bounty: (req: CreateBountyRequest) -> (CreateBountyResult);
   icrc127_get_bounty: (bounty_id: nat) -> (opt Bounty__1) query;
   icrc127_list_bounties: (filter: opt vec ListBountiesFilter, prev: 
    opt nat, take: opt nat) -> (vec Bounty) query;
   icrc127_metadata: () -> (ICRC16Map) query;
   icrc127_submit_bounty: (req: BountySubmissionRequest) ->
    (BountySubmissionResult);
   is_bounty_ready_for_collection: (bounty_id: BountyId, potential_claimant:
    principal) -> (bool) query;
   /// * List all API keys for the authenticated verifier.
   list_api_keys: () -> (vec ApiCredential);
   /// * Get all currently assigned jobs (for debugging/monitoring).
   list_assigned_jobs: () -> (vec record {
                                    BountyId;
                                    AssignedJob;
                                  }) query;
   /// * @notice Fetches a paginated and filtered list of all bounties.
   ///    * @param req The request object containing optional filters and pagination cursors.
   ///    * @return A result containing an array of matching `ICRC127Lib.Bounty` records or an error.
   list_bounties: (req: BountyListingRequest) ->
    (BountyListingResponse) query;
   /// * Get all pending verification jobs with pagination (for debugging/monitoring).
   list_pending_jobs: (offset: opt nat, limit: opt nat) ->
    (record {
       jobs: vec record {
                   text;
                   VerificationJob;
                 };
       total: nat;
     }) query;
   /// * Mark a verification job as complete.
   ///    * Called by mcp_registry when a WASM verification or audit is finalized.
   ///    * Only the registry canister can call this function.
   ///    * @param wasm_id - The WASM ID
   ///    * @param audit_type - The audit type (e.g., "build_reproducibility_v1", "tools_v1")
   mark_verification_complete: (wasm_id: text, audit_type: text) -> (Result);
   /// * Release a job assignment when verification is complete or expired.
   ///    * Can be called by the verifier or by cleanup processes.
   release_job_assignment: (bounty_id: BountyId) -> (Result);
   release_stake: (bounty_id: BountyId) -> (Result);
   /// * Request a verification job assignment.
   ///    * Called by verifier bots using their API key.
   ///    * Returns a job assignment with bounty_id, or an error if no jobs available.
   ///    *
   ///    * PERFORMANCE OPTIMIZATION:
   ///    * Instead of checking participation for each job individually (N jobs × M verifiers = lots of calls),
   ///    * we batch-check participation for ALL jobs that need verifiers upfront (M verifiers × 1 batch each).
   ///    * This dramatically reduces inter-canister calls to mcp_registry.
   request_verification_job_with_api_key: (api_key: text) -> (Result_3);
   /// * Allows a verifier to stake tokens to reserve a bounty (1-hour lock).
   ///    * Can be called directly by the verifier principal.
   ///    * @param bounty_id - The bounty to reserve
   ///    * @param audit_type - The audit type (e.g., "tools_v1", "build_reproducibility_v1")
   reserve_bounty: (bounty_id: BountyId, audit_type: text) -> (Result);
   /// * Reserve a bounty using an API key (for bot authentication).
   ///    * The bot passes its API key, and we resolve it to the verifier principal.
   ///    * @param api_key - The verifier's API key
   ///    * @param bounty_id - The bounty to reserve
   ///    * @param audit_type - The audit type (e.g., "tools_v1", "build_reproducibility_v1")
   reserve_bounty_with_api_key: (api_key: text, bounty_id: BountyId,
    audit_type: text) -> (Result);
   /// * Revoke an API key (makes it inactive).
   revoke_api_key: (api_key: text) -> (Result);
   set_bounty_sponsor_canister_id: (bounty_sponsor_id: principal) -> (Result);
   set_owner: (new_owner: principal) -> (Result);
   set_registry_canister_id: (registry_id: principal) -> (Result);
   /// * Set the stake requirement for a specific audit type.
   ///    * @param audit_type - The audit type (e.g., "tools_v1", "build_reproducibility_v1")
   ///    * @param token_id - The ledger canister ID for the staking token
   ///    * @param amount - The stake amount required (in token's smallest unit)
   set_stake_requirement: (audit_type: text, token_id: TokenId, amount:
    Balance) -> (Result);
   /// * Called by the registry when a verifier was on the losing side of consensus.
   ///    * Slashes their stake and penalizes reputation (they provided incorrect verification).
   ///    * Can also be called by the owner for administrative purposes.
   slash_stake_for_incorrect_consensus: (bounty_id: BountyId) -> (Result);
   /// * Validate an API key and return the associated verifier principal.
   ///    * Used by the verifier bot to authenticate reserve_bounty requests.
   validate_api_key: (api_key: text) -> (Result_2) query;
   /// Withdraw USDC or other ICRC-2 tokens from the audit_hub treasury
   /// Only the owner can call this function
   withdraw: (ledger_id: principal, amount: nat, destination: Account) ->
    (Result_1);
   /// * Withdraw tokens from the verifier's available balance (not currently staked).
   ///    * The withdrawal amount will have the token's fee deducted from it during transfer.
   ///    * @param token_id - The ledger canister ID (as Principal text) of the token to withdraw
   ///    * @param amount - The amount to withdraw (in token's smallest unit) - this is what the user will receive
   withdraw_stake: (token_id: TokenId, amount: Balance) -> (Result);
 };
type AssignedJob = 
 record {
   assigned_at: Timestamp__1;
   audit_type: text;
   bounty_id: BountyId;
   expires_at: Timestamp__1;
   verifier: principal;
   wasm_id: text;
 };
type ApiCredential = 
 record {
   api_key: text;
   created_at: Timestamp__1;
   is_active: bool;
   last_used: opt Timestamp__1;
   verifier_principal: principal;
 };
type Account__1 = 
 record {
   owner: principal;
   subaccount: opt blob;
 };
type Account = 
 record {
   owner: principal;
   subaccount: opt Subaccount;
 };
service : () -> AuditHub
